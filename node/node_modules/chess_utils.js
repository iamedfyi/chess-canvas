exports.build_move_tree = build_tree;
exports.get_pgn_meta_data = get_pgn_meta_data;
exports.load_PGN = load_PGN;
exports.PGN_to_fen_list = PGN_to_fen_list;

var ch = require('/Users/tompearson/Sites/vendor/chess.js');
var fs = require('fs');

function load_PGN(file_name, filter){	//filter provides a crude way to get a sub set of a PGN file
	var games_string = fs.readFileSync(file_name,'utf8'); 
	var games_list = games_string.replace(/\[Event/g, "!NEW GAME![Event").split('!NEW GAME!');
	for (var i = 0; i < games_list.length; i++){
		games_list[i] = {
			game_data:games_list[i],
			meta_data:get_pgn_meta_data(games_list[i])
		};
	}

	if(filter){	//if a filter is specified only return PGN strings that contain the silter string
		var filtered_list = [];
		for(var i = 0; i<games_list.length; i++){
			if(games_list[i].data.indexOf(filter) > -1){
				filtered_list.push(games_list[i]);
			}
		}
		return filtered_list;
	}
	return games_list;
}

function PGN_to_fen_list(pgn){
	var c = new ch.Chess();
	c.load_pgn(pgn);
	var moves = c.history();
	console.log(c.fen());
	c.reset();
	var fens = [];
	fens.push(c.fen());
	for(var turn = 0; turn < moves.length; turn++){
		console.log(moves[turn]);
		c.move(moves[turn]);
		fens.push(c.fen());
	}
	return fens;
}

function get_pgn_meta_data(pgn){
	var data = {};
	var lines = pgn.split(/\n/); 		//go through the lines of the PGN string
	for (var i = 0; i<lines.length ; i++){
		//grab everything that is enclosed by [] on each line
		var meta_regex = /\[(\w+) "(.+)"\]/g;
		var matches = meta_regex.exec(lines[i]);
		if(matches){
			data[matches[1]] = matches[2];
		}
	}
	return data;
}

function build_tree(games, move_limit){
	var move_tree = {
		name:"move 0",
		move:"", 
		children:[],
		games:[]
	};
	var node_lookup = {};
	var games_lookup = [];
	var node_count = 1;
	for(var i = 0; i<games.length;i++){
		var game = new ch.Chess();
		game.load_pgn(games[i].game_data);
		var history = game.history();
		var current_node = move_tree;

		var node_name = "";
		games_lookup[i] = games[i].meta_data;
		for(var m = 0; m<history.length; m++){
			if(move_limit){
				if(m>move_limit){break;}
			}
			current_node.games.push(i);
			var move = history[m];
			var next_index = -1;
			//get the index of the node with this move as its name
			node_name = node_name + "_" + move;	 // SHOULD give us a unique and repeatable id
			for(var c = 0; c < current_node.children.length; c++){
				if(current_node.children[c].move == move){
					next_index = c;
				}
			}
			//if it doesn't exist create it
			if(next_index < 0){	
				node_count ++;
				current_node.children.push({
					name:node_name,
					move:move,
					games:[],
					children:[]
				});
				next_index = current_node.children.length - 1; 
			}

			//set it as the current node
			current_node = current_node.children[next_index];
			//push the game id
			

			if(next_index < 0){
				util.puts("ERROR! current_node = " + current_node);
			}
		}

	}

	var output_struct = {
		tree:move_tree,
		lookup:node_lookup,
		games:games
	};
	console.log("made a tree with " + node_count + " nodes ");
	return output_struct;
}

function uniqueArray(unordered) { //return a de-duplicated version of an array
	var result = [];
	var object = {};
	unordered.forEach(function(item) {
		object[item] = null;
	});
	result = Object.keys(object);
	return result.sort();
}