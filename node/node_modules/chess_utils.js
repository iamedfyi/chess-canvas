exports.build_move_tree = build_tree;
exports.get_pgn_meta_data = get_pgn_meta_data;
exports.load_PGN = load_PGN;

var ch = require('/Users/tompearson/Sites/vendor/chess.js');
var fs = require('fs');

function load_PGN(file_name, filter){	//filter provides a crude way to get a sub set of a PGN file
	var games_string = fs.readFileSync(file_name,'utf8'); 
	var games_list = games_string.replace(/\[Event/g, "!NEW GAME![Event").split('!NEW GAME!');
	if(filter){	//if a filter is specified only return PGN strings that contain the silter string
		var filtered_list = [];
		for(var i = 0; i<games_list.length; i++){
			if(games_list[i].indexOf(filter) > -1){
				filtered_list.push(games_list[i]);
			}
		}
		return filtered_list;
	}
	return games_list;
}

function get_pgn_meta_data(pgn){
	var data = {};
	var lines = pgn.split(/\n/); 		//go through the lines of the PGN string
	for (var i = 0; i<lines.length ; i++){
		//grab everything that is enclosed by [] on each line
		var meta_regex = /\[(\w+) "(.+)"\]/g;
		var matches = meta_regex.exec(lines[i]);
		if(matches){
			this.data[matches[1]] = matches[2];
		}
	}
	return data;
}

function build_tree(sequences){
	var move_tree = {
		name:"move 0", 
		children:[]
	};
	var node_lookup = {}

	for(var i = 0; i<sequences.length;i++){
		var game = new ch.Chess();
		game.load_pgn(sequences[i].moves);
		var history = game.history();
		var current_node = move_tree;
		var node_name = "";
		for(var m = 0; m<history.length; m++){
			var move = history[m];
			var next_index = -1;
			//get the index of the node with this move as its name
			node_name = node_name + "_" + move;	 // SHOULD give us a unique and repeatable id
			for(var c = 0; c < current_node.children.length; c++){
				if(current_node.children[c].move == move){
					next_index = c;
				}
			}
			//if it doesn't exist create it
			if(next_index < 0){	
				current_node.children.push({
					name:node_name,
					move:move,
					children:[]
				});
				next_index = current_node.children.length - 1; 
			}
			if(!node_lookup[node_name]){
				node_lookup[node_name] = {
					weight:0,
					opening_groups:[],
					opening_ending:""
				};
			}	
			//set it as the current node
			current_node = current_node.children[next_index];
			//update counts
			node_lookup[node_name].weight ++;
			node_lookup[node_name].opening_groups.push(sequences[i].ECO[0]);
			if(m == history.length-1){
				node_lookup[node_name].opening_ending = sequences[i].name + "(" +  sequences[i].ECO + ")";
			}
			if(next_index < 0){
				util.puts("ERROR! current_node = " + current_node);
			}
		}
	}

	//de duplicate all the opening group arrays
	for(var n in node_lookup){
		node_lookup[n].opening_groups = uniqueArray(node_lookup[n].opening_groups);
	}

	var output_struct = {
		tree:move_tree,
		lookup:node_lookup
	};

	return output_struct;
}

function uniqueArray(unordered) { //return a de-duplicated version of an array
	var result = [];
	var object = {};
	unordered.forEach(function(item) {
		object[item] = null;
	});
	result = Object.keys(object);
	return result.sort();
}