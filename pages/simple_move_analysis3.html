<!DOCTYPE html>
<html>
<head>
	<title>Move analysis</title>
	<link rel="stylesheet" type="text/css" href="/css/chess_style.css">
	<script type="text/javascript" src="/js/vendor/signals.min.js"></script>
	<script type="text/javascript" src="/js/vendor/chess.js"></script>
	<script type="text/javascript" src="/js/vendor/easeljs-0.5.0.min.js"></script>
	<script type="text/javascript" src="/js/vendor/d3.v2.min.js"></script>
	<script type="text/javascript" src="/js/ChessOpenings.js"></script>
	<script type="text/javascript" src="/js/PGNSplitter.js"></script>
	<script type="text/javascript" src="/js/GameMetaData.js"></script>
	<script type="text/javascript" src="/js/ChessPlayback.js"></script>
	<script type="text/javascript" src="/js/utils.js"></script>

	<script type="text/javascript">


	function go(){	
		d3.csv('/generated_data/move_analysis_wang_vs_anand.csv', draw); 
	}

	function draw(rows){
		//add board positions to the rows
		var chess = new Chess();
		for (var r = 0; r<rows.length; r++){
			if(r != 0){
				chess.move(rows[r].move);
				rows[r].last_pawn_strength = rows[r-1].pawn_strength;
			}
			rows[r].board = chess.ascii();
			if(rows[r].turn%1 != 0){
				rows[r].houdini_rank = -rows[r].houdini_rank;
			}
		}

		var black_rows = [];
		var white_rows = [];

		var margin = 20;
		var w = 700;
		var h = 600;

		//scales
		var absolute_max_ps = Math.max(
			Math.abs(d3.min(rows, getPawnStrength)),
			Math.abs(d3.max(rows, getPawnStrength))
		)

		var rank_domain = [-4, +4];

		var distance = d3.scale.linear()
			.domain([0, rows.length])
			.range([0, 350])

		var angle = d3.scale.linear()
			.domain(rank_domain)
			.range([-Math.PI/4 , Math.PI/4]);
		


		//add the root
		var vis = d3.select("#d3_viz")
		    .append("svg:svg")
			.attr("class", "d3_chart")
			.attr("id", "move_analysis")
		    .attr("width", w)
		    .attr("height", h);

		//draw the data lines
		vis.selectAll("#move_analysis")
			.data(rows).enter()
			.append("svg:line")
				.attr("x1",function(d,i){
					return getLastPos(i,rows,"x");
				})
				.attr("y1",function(d,i){
					return getLastPos(i,rows,"y");
				})
				.attr("x2",function(d,i){
					return getNewPos(i,rows,"x");
				})
				.attr("y2",function(d,i){
					return getNewPos(i,rows,"y");
				})
				.attr("fill","none")
				.attr("stroke", getTurnColour)
				.attr("transform", function(d,i){ return "translate(300,400), rotate(-90)" });

	function getLastPos(i,rows,axis){
		console.log("last " + i);
		var last_index = i-2;
		if(last_index < 1){
			if(last_index == 0){
				rows[last_index][axis] = 0;		
			}
			return 0;
		}
		if(!rows[last_index]){
			return 0;
		}
		return rows[last_index][axis];
	}

	function getNewPos(i, rows, axis){
		console.log("new  " + i);
		var turn_length = 10;
		var last_value = getLastPos(i, rows, axis);
		var difference;
		if(axis == "x"){
			difference = turn_length * Math.sin( angle(rows[i].houdini_rank) );
		}else{
			difference = turn_length * Math.cos( angle(rows[i].houdini_rank) );
		}
		rows[i][axis] = last_value + difference;
		return rows[i][axis];
	}
	}

	function getTurnColour(d,i){
		return "#ffffff";
	}

	

	function getTipText(d,i,rows){		
		if (!d.move){
			d=rows[i]
		}
		return "["+Math.floor(d.turn)+"] "+getPlayer(i) +" move: " + d.move + "<br>Pawn strength " + d.pawn_strength + "<br>Houdini thought this " + houdiniRankToWords(d.houdini_rank)
		+ "<pre>"+d.board+"</pre>";
	}

	function houdiniRankToWords(i){
		var descriptions = [
			'was the best choice',
			'wasn&apos;t a bad choice',
			'was alright',
			'was a bad choice'
		]
		return descriptions[i];
	}

	function getPlayer(i){
		if(i%2 == 0){
			return "Black"
		}
		return "White"
	}

	function getMoveColour(d,i){
		if(i%2 == 0){
			return '#000000'
		}
		return '#222';
	}

	function getMoveHighlightColour(d,i){
		if(i%2 == 0){
			return '#777'
		}
		return '#bbb';
	}

	function getMoveID(d,i){
		return "move_" + i;
	}

	function getRectID(d,i){
		return "rect_" + i;
	}

	function getPawnStrength(i){
		return i["pawn_strength"];
	}

	function getHoudiniRank(i){
		return i["houdini_rank"];	
	}

	function getHoudiniColour(i){
		var colour_rank = [
			'#00FF00',
			'#AAFF00',
			'#FFAA00',
			'#FF0000'
		]
		return colour_rank[i.houdini_rank];
	}



	</script>
	<style type="text/css">
		.label{
			border-bottom: solid;
			border-width: 1px;
			border-color: #fff;
			position: absolute;
			color: #fff;
		}

		.link {
			fill: none;
			//stroke: #000;
			//stroke-width: 1px;
		}

	</style>
</head>
<body onLoad="go()">
<div class="info_panel" id="info">
	A visalisation of "houdini rank" for each players moves i.e. is the move taken one of those which Houdini reccomended after a given amount of processing time. Wang (w) vs Anand (b) - Tata Steel... round 13, 27th Jan. 
</div>
<div class='tooltip'>
	tooltip
</div>
<div class="visualisation" id="d3_viz">
</div>


</body>
</html>